function f(e,r){class n{constructor(t){var s;const i=this;n.init(i,t),(s=i._zod).deferred??(s.deferred=[]);for(const c of i._zod.deferred)c()}static init(t,s){var i;t._zod??(t._zod={}),(i=t._zod).traits??(i.traits=new Set),t._zod.traits.add(e),r(t,s);for(const c in n.prototype)Object.defineProperty(t,c,{value:n.prototype[c].bind(t)});t._zod.constr=n,t._zod.def=s}static[Symbol.hasInstance](t){var s,i;return(i=(s=t==null?void 0:t._zod)==null?void 0:s.traits)==null?void 0:i.has(e)}}return Object.defineProperty(n,"name",{value:e}),n}class m extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}const M={};function p(e){return M}function O(e,r){return typeof r=="bigint"?r.toString():r}function k(e){const r=e.startsWith("^")?1:0,n=e.endsWith("$")?e.length-1:e.length;return e.slice(r,n)}function R(e=10){const r="abcdefghijklmnopqrstuvwxyz";let n="";for(let o=0;o<e;o++)n+=r[Math.floor(Math.random()*r.length)];return n}function A(e,r){return new e._zod.constr(r)}function Z(e){return{}}function $(e,r=0){for(let n=r;n<e.issues.length;n++)if(e.issues[n].continue!==!0)return!0;return!1}function g(e){return typeof e=="string"?e:e==null?void 0:e.message}function _(e,r,n){var t,s,i,c,u,a;const o={...e,path:e.path??[]};if(!e.message){const l=g((i=(s=(t=e.inst)==null?void 0:t._zod.def)==null?void 0:s.error)==null?void 0:i.call(s,e))??g((c=r==null?void 0:r.error)==null?void 0:c.call(r,e))??g((u=n.customError)==null?void 0:u.call(n,e))??g((a=n.localeError)==null?void 0:a.call(n,e))??"Invalid input";o.message=l}return delete o.inst,delete o.continue,r!=null&&r.reportInput||delete o.input,o}const T=Symbol.for("{{zod.error}}");class h{get message(){return JSON.stringify(this.issues,O,2)}constructor(r){Object.defineProperty(this,"_tag",{value:T,enumerable:!1}),Object.defineProperty(this,"name",{value:"$ZodError",enumerable:!1}),this.issues=r}static[Symbol.hasInstance](r){return(r==null?void 0:r._tag)===T}}function j(e,r,n){const o=n?{...n,async:!1}:{async:!1},t=e._zod.run({value:r,issues:[]},o);if(t instanceof Promise)throw new m;if(t.issues.length)throw new((this==null?void 0:this.Error)??h)(t.issues.map(s=>_(s,o,p())));return t.value}function q(e,r,n){const o=n?{...n,async:!1}:{async:!1},t=e._zod.run({value:r,issues:[]},o);if(t instanceof Promise)throw new m;return t.issues.length?{success:!1,error:new((this==null?void 0:this.Error)??h)(t.issues.map(s=>_(s,o,p())))}:{success:!0,data:t.value}}async function I(e,r,n){const o=n?{...n,async:!0}:{async:!0};let t=e._zod.run({value:r,issues:[]},o);if(t instanceof Promise&&(t=await t),t.issues.length)throw new((this==null?void 0:this.Error)??h)(t.issues.map(s=>_(s,o,p())));return t.value}async function L(e,r,n){const o=n?{...n,async:!0}:{async:!0};let t=e._zod.run({value:r,issues:[]},o);return t instanceof Promise&&(t=await t),t.issues.length?{success:!1,error:new((this==null?void 0:this.Error)??h)(t.issues.map(s=>_(s,o,p())))}:{success:!0,data:t.value}}const N=e=>{const r=e?`[\\s\\S]{${(e==null?void 0:e.minimum)??0},${(e==null?void 0:e.maximum)??""}}`:"[\\s\\S]*";return new RegExp(`^${r}$`)},C={major:0,minor:6,patch:2},w=f("$ZodType",(e,r)=>{var t,s,i;var n;e??(e={}),e._zod.id=r.type+"_"+R(10),e._zod.def=r,e._zod.computed=e._zod.computed||{},e._zod.version=C;const o=[...e._zod.def.checks??[]];r.type,e._zod.traits.has("$ZodCheck")&&o.unshift(e);for(const c of o)(s=(t=c._zod).onattach)==null||s.call(t,e);if(o.length===0)(n=e._zod).deferred??(n.deferred=[]),(i=e._zod.deferred)==null||i.push(()=>{e._zod.run=e._zod.parse});else{const c=(u,a,l)=>{let d=$(u),z;for(const v of a){if(v._zod.when){if(!v._zod.when(u))continue}else if(d)continue;const y=u.issues.length,b=v._zod.check(u);if(b instanceof Promise&&(l==null?void 0:l.async)===!1)throw new m;if(z||b instanceof Promise)z=(z??Promise.resolve()).then(async()=>{await b,u.issues.length!==y&&(d||(d=$(u,y)))});else{if(u.issues.length===y)continue;d||(d=$(u,y))}}return z?z.then(()=>u):u};e._zod.run=(u,a)=>{const l=e._zod.parse(u,a);if(l instanceof Promise){if(a.async===!1)throw new m;return l.then(d=>c(d,o,a))}return c(l,o,a)}}e["~standard"]={validate:c=>{const u=e._zod.run({value:c,issues:[]},{});return u instanceof Promise?u.then(({issues:a,value:l})=>a.length===0?{value:l}:{issues:a.map(d=>_(d,{},p()))}):u.issues.length===0?{value:u.value}:{issues:u.issues.map(a=>_(a,{},p()))}},vendor:"zod",version:1}}),U=f("$ZodString",(e,r)=>{var n;w.init(e,r),e._zod.pattern=((n=e==null?void 0:e._zod.computed)==null?void 0:n.pattern)??N(e._zod.computed),e._zod.parse=(o,t)=>{if(r.coerce)try{o.value=String(o.value)}catch{}return typeof o.value=="string"||o.issues.push({expected:"string",code:"invalid_type",input:o.value,inst:e}),o}}),V=f("$ZodOptional",(e,r)=>{w.init(e,r),e._zod.qout="true",r.innerType._zod.values&&(e._zod.values=new Set([...r.innerType._zod.values,void 0]));const n=r.innerType._zod.pattern;n&&(e._zod.pattern=new RegExp(`^(${k(n.source)})?$`)),e._zod.parse=(o,t)=>o.value===void 0?o:r.innerType._zod.run(o,t)}),W=f("$ZodNullable",(e,r)=>{w.init(e,r),e._zod.qin=r.innerType._zod.qin,e._zod.qout=r.innerType._zod.qout;const n=r.innerType._zod.pattern;n&&(e._zod.pattern=new RegExp(`^(${k(n.source)}|null)$`)),r.innerType._zod.values&&(e._zod.values=new Set([...r.innerType._zod.values,null])),e._zod.parse=(o,t)=>o.value===null?o:r.innerType._zod.run(o,t)});function D(e,r){return new e({type:"string",...Z()})}const H=j.bind({Error:h}),J=q.bind({Error:h}),B=I.bind({Error:h}),F=L.bind({Error:h}),E=f("ZodMiniType",(e,r)=>{if(!e._zod)throw new Error("Uninitialized schema in mixin ZodMiniType.");w.init(e,r),e.def=r,e.parse=(n,o)=>H(e,n,o),e.safeParse=(n,o)=>J(e,n,o),e.parseAsync=async(n,o)=>B(e,n,o),e.safeParseAsync=async(n,o)=>F(e,n,o),e.check=(...n)=>e.clone({...r,checks:[...r.checks??[],...n.map(o=>typeof o=="function"?{_zod:{check:o,def:{check:"custom"}}}:o)]}),e.clone=n=>A(e,n??r),e.brand=()=>e,e.register=(n,o)=>(n.add(e,o),e)}),G=f("ZodMiniString",(e,r)=>{U.init(e,r),E.init(e,r)});function K(e){return D(G)}const Q=f("ZodMiniOptional",(e,r)=>{V.init(e,r),E.init(e,r)});function X(e,r){return new Q({type:"optional",innerType:e,...Z()})}const Y=f("ZodMiniNullable",(e,r)=>{W.init(e,r),E.init(e,r)});function x(e,r){return new Y({type:"nullable",innerType:e,...Z()})}function ee(){console.log("goodbye son")}const re=x(X(K())),P=re.safeParse("hi");if(P.success)console.log("Valid data:",P.data),ee();else{const e=P.error.issues;for(const r of e)console.error("Validation Error:",r)}
//# sourceMappingURL=bundle.js.map
